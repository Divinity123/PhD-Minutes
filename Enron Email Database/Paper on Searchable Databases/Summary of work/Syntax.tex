\subsection{Syntax of Database}
A database $\db$ consists of a set of keywords $\KWset$ and a set of files $\File$, so $\db = (\KWset, \File)$. Each file $\file \in \File$ contains some keywords specified by the user. For simplicity of notation, we denote keywords associated to a file $\kwset = \KWset(\file)$. The database supports queries via function $\QueryFunction: \DB \times \Query \rightarrow \DB \times \Response$, where $\Query$ is a set of queries on the database and $\Response$ is some response. Since we are talking about encryptions for searching, searching of keywords must be one of the supported query types.


\subsection{Syntax of Encrypted Database}
An encrypted database $\edb$ consists of a set of encrypted keywords $\EKWset$, a set of encrypted files $\EFile$ and an encrypted index $\EIndex$ for encrypted queries, so $\edb = (\EKWset, \EFile, \EIndex)$. Each encrypted file $\efile \in \EFile$ contains some encrypted keywords which are encryptions of corresponds keywords for the plain files. Similar to unencrypted databases, we denote encrypted keywords associated to an encrypted file by $\ekwset = \EKWset(\efile)$. The encrypted database supports encrypted queries via function $\EQueryFunction: \EDB \times \EQuery \rightarrow \EDB \times \EResponse$.


\subsection{Functions between Database and Encrypted Database}
A mechanism for searchable encrypted database supports the following operations:
\begin{itemize}
	\item \textbf{Key generation:} $\kgen: \secparam \rightarrow \key$. The key generation algorithm takes in the security parameter and outputs keys used for the mechanism.
	
	\item \textbf{Encryption:} $\enc: \secparam \times \key \times \DB \rightarrow \EDB$. The encryption scheme takes in security parameter, a key and a database, and produce an encrypted database.
	
	\item \textbf{Decryption:} $\dec: \secparam \times \key \times \EDB \rightarrow \DB$. The decryption scheme takes in security parameter, a key and an encrypted database, and produce a database.
	
	\item \textbf{Query:} $\QueryFunction: \DB \times \Query \rightarrow \DB \times \Response$. A query function takes in a database and a query and outputs a response.
	
	\item \textbf{Query encryption:} $\EncQ: \key \times \Query \rightarrow \EQuery \times \QState$. The query encryption function takes in a key and a query, and produces an encrypted query and a state which will be used to decrypt encrypted response later.
	
	\item \textbf{Encrypted queries:} $\EQueryFunction:\EDB \times \EQuery \rightarrow \EDB \times \EResponse$. An encrypted query takes an encrypted database and an encrypted query, and returns an encrypted database and an encrypted response.
	
	\item \textbf{Response decryption:} $\DecResponse: \key \times \EResponse \times \QState \rightarrow \Response$. The response decryption function takes a key, an encrypted response, and a state, and returns a response.
\end{itemize}
When the security parameter and the key are obvious, we may omit them from the notation. We may abuse $\enc(\cdot)$ and $\dec(\cdot)$ as encryption and decryption functions on keywords, for example, $\ekw = \enc(\kw)$.


\subsection{Correctness Requirements and Commutative Diagram}
We say that a mechanism for searchable encrypted database is correct if the following holds:
\begin{itemize}
	\item \textbf{Correctness of encryption scheme:} For all databases $\db \in \DB$, $\dec(\enc(\db)) = \db$.
	
	\item \textbf{Correctness of encrypted query function on the database:} For any query $q \in \Query$ and $\db \in \DB$, $\dec(\Pi_1(\EQueryFunction(\enc(db), \Pi_1(\EncQ(\query))))) = \Pi_1(\QueryFunction(\db, \query))$.
	
	\item \textbf{Correctness of encrypted query function on the response:} For any query $q \in \Query$ and $\db \in \DB$, let $(\equery, \qState) = \EncQ(\query)$, then $\DecResponse(\Pi_2(\EQueryFunction(\enc(\db),\equery)), \qState) = \Pi_2(\QueryFunction(\db, \query))$.
\end{itemize}


\begin{figure}[H]
	\centering
	\begin{tikzpicture}[node distance=3cm, auto]
		\node (DB) {$\DB$};
		\node (EDB) 	[right of=DB] 	{$\EDB$};
		\node (Q)   	[below of=DB] 	{$\Query$};
		\node (DBxQ)	[below left of=DB, node distance=2.2cm] {$\DB \times \Query$};
		\node (DBxR)	[left of=DB, node distance = 4.5cm] {$\DB \times \Response$};
		\node (EQxQST)	[right of=Q]	{$\EQuery \times \QState$};
		\node (EQ)  	[above right of=EQxQST, node distance=2.2cm] 	{$\EQuery$};
		\node (QST)		[below right of=EQxQST, node distance=2.2cm] 	{$\QState$};
		\node (EDBxEQ)	[right of=EQ]	{$\EDB \times \EQuery$};
		\node (EDBxER) 	[right of=EDB, node distance = 8.4cm]	{$\EDB \times \EResponse$};
		\node (R)		[below of=DBxR, node distance=6.6cm]	{$\Response$};
		\node (ER)		[below of=EDBxER, node distance=6.6cm]	{$\EResponse$};
		\node (ERxQST)	[below of=QST, node distance=2cm] {$\EResponse \times \QState$};	
		
		\draw[->,transform canvas={yshift=0.3em}] (DB) to node {$\enc$} (EDB);
		\draw[->,transform canvas={yshift=-0.3em}] (EDB) to node {$\dec$} (DB);
		\draw[->] (DB) to (DBxQ);
		\draw[->] (Q) to (DBxQ);
		\draw[->] (DBxQ) to node[below,xshift=-0.4cm] {$\QueryFunction$} (DBxR);
		\draw[->, dashed] (DBxR) to node {$\Pi_1$} (DB);
		\draw[->] (DBxR) to node {$\Pi_2$} (R);
		
		\draw[->] (Q) to node {$\EncQ$} (EQxQST);
		\draw[->] (EQxQST) to node {$\Pi_1$} (EQ);
		\draw[->] (EQxQST) to node[below] {$\Pi_2$} (QST);
		\draw[->] (EQ) to node {} (EDBxEQ);
		\draw[->] (EDB) to node {} (EDBxEQ);
		\draw[->] (EDBxEQ) to node[below, xshift=0.4cm] {$\EQueryFunction$} (EDBxER);
		\draw[->,dashed] (EDBxER) to node {$\Pi_1$} (EDB);
		\draw[->] (EDBxER) to node {$\Pi_2$} (ER);
		 
		\draw[->] (QST) to node {} (ERxQST);
		\draw[->] (ER) to node {} (ERxQST);
		\draw[->] (ERxQST) to node {$\DecResponse$} (R);
	\end{tikzpicture}
	\caption{Commutative diagram for mechanism on searchable encrypted database.}	
\end{figure}